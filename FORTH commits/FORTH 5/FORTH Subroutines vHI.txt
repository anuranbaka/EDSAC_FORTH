[File of subroutines for FORTH]
[Over time, this file seems to be
evolving into a full FORTH system]

[
-------------
MEMORY LAYOUT
-------------
* = is address (preshifted 1)
? = is binary (<0 = True)

56-63  Junk Registers


64 IP            PFA        0 1
66 IP_odd?       IP_word*   2 3
68 token         &CFA       4 5
70 W             X          6 7
72 Y             Z          8 9
74 SP            RP         10 11
76 LATEST        HERE       12 13]

[----------------------------
Forward declarations
-----------------------------]
[Dictionary] T48K  P 256 F [set dict address in &(=48)]
[Registers]  T45K  P 64  F [set register address in H(=45)]
[Constants]  T46K  P 768 F [in N(=46)]
[Builtins]   T53K  P 512 F [in B(=53)]

[Magic Incantations to know:
 T22K R2047 {?}
      -- Starts assembling at the location in function parameter ?
         Works by setting the transfer order to "T 0 ? - 1F"
 E25K T{X}{?}
      -- Same as above, but can offset by X
         Works by jumping out over the transfer increment on next order
         assembled, as long as it's positive
 E25K E{?}
      -- Jump out of assembler to location *
 GK
      -- Sets @ to next instruction

]


[constants]
E25K TN [Assemble at N]
P0D    [0: "1"]
A0F    [1: "A0F"]
P63D   [2: "0x7F"]
E0F    [3: "E0F"]
B1F    [4: "1F - E0F"]
P&     [5: "dict"]
A1F    [6: "A1F"]
P8D    [7: "17"]
P8456F [8: "<...>"]

[the Dictionary]
T22K R2047&    [Assemble at &]
ZF P& [sentinal entry 0 that says to jump to ZF]



[----------------------------]
[SUB NEXT part 1: load the token at token address given in the IP}
[----------------------------]

E25K TB
GK
A H   [A ip F]
A 0 N [A "1" F]
U H   [U ip F]
R 1 F
U 2 #H [U tmp0 D / U IP_odd? D]
L 0 D
T 3 H  [T tmp1 F/ T &IP_word F]
A 3 H  [A tmp1 F]
L 0 D
A 1 N  [A "A 0 F" F]
T 11 @  [T ifetch F]
ZF     [:ifetch: (A * F) ]
A 2 H  [A tmp0 F / A IP_odd? F]
G 15 @ [G lo F]
R 64 F
T 4 H [:lo: T tmp2 F / T token F]
H 2 N [H "0xFF" F]
C 4 H [C tmp2 F / C token F]
U 4 H [U token F]
[TOKEN is in acc and correct]
XF [No-op, in case we want to temp jump somewhere]
[----------------------------]
[SUB NEXT part 2:  load the CFA,PFA for TOKEN given in the accumulator
 and GOOOOOOOOOO!}
[----------------------------]
GK
L 1 F
A 5 N [A "dict" F]
A 6 N [A "A 1 F" F]
T 4 @ [T fchcfa F]
ZF    [:fchcfa: (A*F) ]
A 3 N [ A "E 0 F" F]
U 10 @ [ U t1 F ]
A 4 N [ A "1F - E 0 F" F ]
T 1 H [ T pfa F ]
XF    [debug noop]
ZF    [ :t1: (E * F) Jump to code!]


[Word 1: Debug: print HI]
GK E25K T2& [ID 1] [add dict entry]
P 8532 F    [<.HI> = 17064]
P 0    @
T49K P@ TZ [in L]
O5@
O6@
O7@
E 0 B [E next F]
ZF
*F
HF
IF











[Debug forth code]
T1000K
P128F  [1,0]
E25K T0H P999D  [set IP so next instruction is 2000]

E25K EB PF



